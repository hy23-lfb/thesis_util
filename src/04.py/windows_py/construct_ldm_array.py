# -*- coding: utf-8 -*-
"""Construct_LDM_Array.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s_kO3Vj9FkIQ0xUFwazP0NDKZexidc51
"""

import os
import argparse
from PIL import Image
import xml.etree.ElementTree as ET
import numpy as np
import math

# parse the commandline
parser = argparse.ArgumentParser()
parser.add_argument('--s-file-path', type=str, required=True, help='root directory that holds folders containing points files.')
args = parser.parse_args()

def construct_landmark_file(atl_points, sub_points, atl_landmark, sub_landmark):
  tree_atl = ET.parse(atl_points)
  root_atl = tree_atl.getroot()

  tree_sub = ET.parse(sub_points)
  root_sub = tree_sub.getroot()

  assert len(root_atl) == len(root_sub), 'Subject and Atlas have different number of landmark points'
  no_of_landmarks = len(root_atl)

  # create list of dictionary attributes.
  dict_attrib_atl = [dict() for x in range(no_of_landmarks)]
  dict_attrib_sub = [dict() for x in range(no_of_landmarks)]

  for i in range(no_of_landmarks):
    dict_attrib_atl[i] = root_atl[i].attrib
    dict_attrib_sub[i] = root_sub[i].attrib

  # create another dictionary with name as key and value as list
  dict_atl = dict()
  dict_sub = dict()

  true_points = 0
  for i in range(no_of_landmarks):
    if(dict_attrib_sub[i]['set']=='true'):
      true_points = true_points + 1
      dict_atl[dict_attrib_atl[i]['name'].lower()] = [math.floor(float(dict_attrib_atl[i]['y'])), math.floor(float(dict_attrib_atl[i]['x'])), math.floor(float(dict_attrib_atl[i]['z']))]
      dict_sub[dict_attrib_sub[i]['name'].lower()] = [math.floor(float(dict_attrib_sub[i]['y'])), math.floor(float(dict_attrib_sub[i]['x'])), math.floor(float(dict_attrib_sub[i]['z']))]

  atl_key_list = sorted(dict_atl)
  sub_key_list = sorted(dict_sub)

  print("true points: {}".format(true_points))
  print()

  # sanity check
  for i in range(true_points):
    assert atl_key_list[i] == sub_key_list[i], 'Landmark names are different.'

  B = np.zeros((2,5), dtype=int)
  [minx, miny, minz, minc] = [0, 0, 0, 0]
  [maxx, maxy, maxz, maxc] = [0, 0, 0, 2]
  
  count = 0
  if(true_points > 0):
    A = np.zeros((true_points, 3), dtype=int)
    for i in atl_key_list:
        tmp_sub = dict_sub[i]
        tmp_atl = dict_atl[i]

        A[count] = np.asarray(tmp_sub)

        sub_landmark[tmp_sub[0], tmp_sub[1], tmp_sub[2], 0] = tmp_sub[0]
        sub_landmark[tmp_sub[0], tmp_sub[1], tmp_sub[2], 1] = tmp_sub[1]
        sub_landmark[tmp_sub[0], tmp_sub[1], tmp_sub[2], 2] = tmp_sub[2]

        atl_landmark[tmp_sub[0], tmp_sub[1], tmp_sub[2], 0] = tmp_atl[0]
        atl_landmark[tmp_sub[0], tmp_sub[1], tmp_sub[2], 1] = tmp_atl[1]
        atl_landmark[tmp_sub[0], tmp_sub[1], tmp_sub[2], 2] = tmp_atl[2]
    
        count = count + 1
  
    [minx, miny, minz, minc] = np.append(np.min(A, axis=0), [0])
    [maxx, maxy, maxz, maxc] = np.append(np.max(A, axis=0), [2])
  
    assert (maxx-minx)<63, 'maxx needs to be greater than 64'
    assert (maxy-miny)<63, 'maxy needs to be greater than 64'
    assert (maxz-minz)<15, 'maxz needs to be greater than 16'

  B[0] = [0, minx, miny, minz, minc]
  B[1] = [0, minx+63, miny+63, minz+15, maxc]
  
  return [atl_landmark, sub_landmark, B, dict_sub, dict_atl]

def performSlicing(atl_landmark, sub_landmark, C):
  [_, minx, miny, minz, minc] = C[0]
  [_, maxx, maxy, maxz, maxc] = C[1]
  
  sub = sub_landmark[minx:maxx+1, miny:maxy+1, minz:maxz+1, minc:maxc+1]
  atl = atl_landmark[minx:maxx+1, miny:maxy+1, minz:maxz+1, minc:maxc+1]
  
  return [atl, sub]

def test_nonzero_indices(atl, sub):
  (x1, y1, z1, c1) = np.where(atl)
  (x2, y2, z2, c2) = np.where(sub)

  assert (x1==x2).all(), 'Atlas and Subject Landmarks are at different xindices'
  assert (y1==y2).all(), 'Atlas and Subject Landmarks are at different yindices'
  assert (z1==z2).all(), 'Atlas and Subject Landmarks are at different zindices'

def test_slicing_op(a, a_slice, C):
  [_, minx, miny, minz, minc] = C[0]
  [_, maxx, maxy, maxz, maxc] = C[1]

  (x1, y1, z1, c1) = np.where(a_slice)
  (x2, y2, z2, c2) = np.where(a)

  assert ((x2-x1)==minx).all(), 'Slicing in x axis is wrong'
  assert ((y2-y1)==miny).all(), 'Slicing in x axis is wrong'
  assert ((z2-z1)==minz).all(), 'Slicing in x axis is wrong'

def test_value_at_indices(sub, sub_landmark, atl_landmark):
  (x,y,z,c)=np.where(sub)
  (ax, ay, az, ac)=(np.where(atl_landmark))
  (sx, sy, sz, sc)=(np.where(sub_landmark))

  if (x.size == 0):
    assert ax.size==0, 'Atl_landmark array is not zero array like subject data.'
    assert sx.size==0, 'Sub_landmark array is not zero array like subject data.'
  
  else:
    values_sub = (sub[x,y,z])
    vx = values_sub[:,0].astype(int)
    vy = values_sub[:,1].astype(int)
    vz = values_sub[:,2].astype(int)

    assert (ax == vx).all(), 'x-index for atlas landmark is wrong'
    assert (ay == vy).all(), 'y-index for atlas landmark is wrong'
    assert (az == vz).all(), 'z-index for atlas landmark is wrong'
    assert (sx == vx).all(), 'x-index for subject landmark is wrong'
    assert (sy == vy).all(), 'x-index for subject landmark is wrong'
    assert (sz == vz).all(), 'x-index for subject landmark is wrong'

def test_shape_of_ldms(atl, sub):
  (ax,ay,az,ac)=atl.shape
  (sx,sy,sz,sc)=sub.shape
   
  assert ax==sx==64, 'Incorrect shape in x direction'
  assert ay==sy==64, 'Incorrect shape in y direction'
  assert az==sz==16, 'Incorrect shape in z direction'
  assert ac==sc==3, 'Incorrect shape in c direction'

def test_validity_of_values(dic_atl, dic_sub, atl, sub):
  sub_list = sorted(dic_sub)
  atl_list = sorted(dic_atl)
  sub_coordinates = []
  atl_coordinates = []
  for key in sub_list:
    sub_coordinates.append(dic_sub[key])

  for key in atl_list:
    atl_coordinates.append(dic_atl[key])
    
  (x,y,z,c)=np.where(sub)

  sub_val = sub[x,y,z]
  atl_val = atl[x,y,z]

  for i in range((sub[x,y,z]).shape[0]):
    sub_elm = list(sub_val[i].astype(int))
    if(sub_elm in sub_coordinates):
      idx = sub_coordinates.index(sub_elm)
    
      # values at i and idx must match.
      atl_elm = list(atl_val[i].astype(int))
      assert atl_elm==atl_coordinates[idx], 'Array indices and Point indices mismatch'
    else:
      assert False, 'sub_elm is not found in sub_coordinates'

def test_dimensions(BB, sub_data):
  [_, maxx, maxy, maxz, maxc] = BB[1]
  (xdim, ydim, zdim, cdim) = sub_data.shape
  assert maxx<xdim, 'xdim are incorrect'
  assert maxy<ydim, 'ydim are incorrect'
  assert maxz<zdim, 'zdim are incorrect'
  assert maxc<cdim, 'cdim are incorrect'

atl_pts = r'I:\00.masterarbeit_dataset\00.atlas\np-scaled-channel\npz\np_atlas_scaled_pixel.points'
  
d_file_path = os.path.join(args.s_file_path, 'ldm_npz')
os.makedirs(d_file_path, exist_ok=True)

# list everything in the path; both directories and files.
dirlist = os.listdir(args.s_file_path)
  
# Of all the directories and files, filter only files
filelist = [file for file in dirlist if (os.path.isfile(os.path.join(args.s_file_path, file)))]
  
# extract list of point files from the filelist.
pointlist = [point for point in filelist if (point.endswith('.points'))]
  
for file_idx in range(len(pointlist)):
#for file_idx in range(327, len(pointlist), 1):
  src_filename = pointlist[file_idx]
  dst_filename = pointlist[file_idx].replace('.points', '_points.npz')
  atl_filename = pointlist[file_idx].replace('.points', '_atlas.npz')
  box_filename = pointlist[file_idx].replace('.points', '_bbox.npz')
   
  # create two arrays
  sub_data = np.zeros((512, 256, 64, 3))
  atl_data = np.zeros((512, 256, 64, 3))

  src_pts = os.path.join(args.s_file_path, src_filename)
  src_npz = os.path.join(d_file_path, dst_filename)
  atl_npz = os.path.join(d_file_path, atl_filename)
  box_npz = os.path.join(d_file_path, box_filename)
  
  print("src_filename: {}".format(src_filename))
  print("dst_filename: {}".format(dst_filename))
  print("atl_filename: {}".format(atl_filename))
  print("box_filename: {}".format(box_filename))
  print("file_idx    : {}".format(file_idx))

  [atl_data, sub_data, BB, dic_sub, dic_atl] = construct_landmark_file(atl_pts, src_pts, atl_data, sub_data)
  [atl_ldms, sub_ldms]                       = performSlicing(atl_data, sub_data, BB)
  
  """# Test"""

  test_nonzero_indices(atl_data, sub_data)
  test_nonzero_indices(atl_ldms, sub_ldms)
  test_slicing_op(atl_data, atl_ldms, BB)
  test_slicing_op(sub_data, sub_ldms, BB)
  test_value_at_indices(sub_ldms, sub_data, atl_data)
  test_shape_of_ldms(atl_ldms, sub_ldms)
  test_validity_of_values(dic_atl, dic_sub, atl_ldms, sub_ldms)
  test_dimensions(BB, sub_data)
  
  #np.savez(atl_npz, atl=atl_ldms)
  #np.savez(src_npz, src=sub_ldms)
  #np.savez(box_npz, box=BB)
  
  # save everything in one single npz file.
  np.savez(src_npz, atl=atl_ldms, src=sub_ldms, box=BB)